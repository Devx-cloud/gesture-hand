<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gesture Launcher - Final with Audio & Particles</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;700&family=Orbitron:wght@700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <canvas id="particle-canvas"></canvas>

    <div class="scan-container">
        <video id="input_video" autoplay playsinline></video>
        <img src="futuristic-arm-removebg-preview.png" class="futuristic-arm-overlay" alt="Futuristic Arm Scan">

        <svg class="progress-circle" viewBox="0 0 100 100">
            <circle id="progress-bg" cx="50" cy="50" r="45"></circle>
            <circle id="progress-bar" cx="50" cy="50" r="45"></circle>
        </svg>

        <div class="ui-text-wrapper">
            <p id="instructions" class="ui-text visible">Letakkan tangan di depan kamera</p>
            <p id="status-message" class="ui-text"></p>
            <p id="countdown-display" class="ui-text"></p>
            <p id="launch-message" class="ui-text"></p>
        </div>
    </div>

    <audio id="beep-sound" src="beep.mp3" preload="auto"></audio>
    <audio id="intro-sound" src="intro-rise1.mp3" preload="auto"></audio>
    <audio id="access-sound" src="access1.mp3" preload="auto"></audio>

    <div id="start-overlay">
        <h1>Gesture Launcher</h1>
        <p>Klik untuk mengaktifkan kamera dan memulai</p>
        <button id="start-button">MULAI</button>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>

    <script>
        // --- SCRIPT UTAMA YANG SUDAH DIMODIFIKASI ---

        // Ambil semua elemen yang dibutuhkan
        const videoElement = document.getElementById("input_video");
        const instructionsElement = document.getElementById("instructions");
        const statusMessageElement = document.getElementById("status-message");
        const countdownDisplayElement = document.getElementById("countdown-display");
        const launchMessageElement = document.getElementById("launch-message");
        const scanContainer = document.querySelector(".scan-container");
        const progressBar = document.getElementById('progress-bar');
        const startOverlay = document.getElementById('start-overlay');
        const startButton = document.getElementById('start-button');
        const beepAudio = document.getElementById('beep-sound');
        const introAudio = document.getElementById('intro-sound');
        const accessAudio = document.getElementById('access-sound');

        // Setup progress bar
        const radius = progressBar.r.baseVal.value;
        const circumference = 2 * Math.PI * radius;
        progressBar.style.strokeDasharray = circumference;

        // Deklarasi variabel global
        let openHandCounter = 0;
        const thresholdFrames = 25;
        let gestureTriggered = false;
        let countdownInterval = null;
        let hands, camera; // Dideklarasikan di sini agar bisa diakses di berbagai fungsi

        // --- FUNGSI-FUNGSI UTAMA ---

        function showElement(el, message = null) {
            document.querySelectorAll('.ui-text').forEach(p => p.classList.remove('visible'));
            if (message) el.innerHTML = message;
            el.classList.add('visible');
        }

        function setProgress(percent, color = null) {
            const offset = circumference - (percent / 100) * circumference;
            progressBar.style.strokeDashoffset = offset;
            if (color) progressBar.style.stroke = color;
        }

        function startCountdown() {
            if (gestureTriggered) return;
            gestureTriggered = true;
            let countdownValue = 3;
            showElement(countdownDisplayElement, countdownValue);

            beepAudio.currentTime = 0;
            beepAudio.play();

            countdownInterval = setInterval(() => {
                countdownValue--;
                if (countdownValue > 0) {
                    beepAudio.currentTime = 0;
                    beepAudio.play();
                }
                countdownDisplayElement.innerHTML = countdownValue;

                if (countdownValue <= 0) {
                    clearInterval(countdownInterval);
                    launchProduct();
                }
            }, 1000);

        }

        async function launchProduct() {
            if (camera) camera.stop();
            videoElement.style.opacity = '0';
            scanContainer.classList.add('identifying');
            showElement(launchMessageElement);

            introAudio.currentTime = 0;
            introAudio.play();

            function animateLoading(percentage) {
                launchMessageElement.innerHTML =
                    `<div class="label">IDENTIFYING</div><div class="loading-percent">${percentage}%</div>`;
                setProgress(percentage, 'var(--primary-glow)');

                let delay = (percentage >= 98) ? 800 : 55;

                if (percentage < 100) {
                    setTimeout(() => animateLoading(percentage + 1), delay);
                } else {
                    setTimeout(() => {

                        //                 if (!introAudio.paused) {
                        //     introAudio.pause();
                        //     introAudio.currentTime = 0;
                        // }

                        scanContainer.classList.add('access-granted');
                        launchMessageElement.innerHTML =
                            `<div class="final-message" style="color: var(--secondary-glow); text-shadow: 0 0 10px var(--secondary-glow);">ACCESS GRANTED</div>`;

                        // ðŸ”Š Tambahkan audio access di sini
                        // introAudio.stop()
                        accessAudio.currentTime = 0;
                        accessAudio.play();

                        let greenPercent = 100;

                        function fillGreenBar() {
                            setProgress(greenPercent, 'var(--secondary-glow)');
                            if (greenPercent < 100) {
                                greenPercent++;
                                setTimeout(fillGreenBar, 10);
                            } else {
                                setTimeout(() => {
                                    window.location.href = "https://www.youtube.com/";
                                }, 1100);
                            }
                        }
                        fillGreenBar();
                    }, 500);
                }

            }
            animateLoading(0);
        }

        function onResults(results) {
            if (gestureTriggered) return;

            const handDetected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;

            if (handDetected) {
                const landmarks = results.multiHandLandmarks[0];
                const isHandOpen = [8, 12, 16, 20].every(i => landmarks[i].y < landmarks[i - 2].y);

                if (isHandOpen) {
                    openHandCounter++;
                    showElement(statusMessageElement,
                        `Validasi... ${Math.round((openHandCounter / thresholdFrames) * 100)}%`);

                    particleColor = 'rgba(0, 255, 255, 0.8)';
                    lineColor = 'rgba(0, 255, 255, 1)';

                    if (openHandCounter >= thresholdFrames) {
                        startCountdown();
                    }
                } else {
                    // Tangan terdeteksi tapi tidak terbuka
                    if (openHandCounter > 0 && openHandCounter < thresholdFrames) {
                        // Tambahkan efek error merah ke scan-container
                        scanContainer.classList.add("error");
                        particleColor = 'rgba(255, 0, 0, 0.8)';
                        lineColor = 'rgba(255, 0, 0, 1)';

                        setTimeout(() => {
                            scanContainer.classList.remove("error");
                            particleColor = 'rgba(0, 255, 255, 0.8)';
                            lineColor = 'rgba(0, 255, 255, 1)';
                        }, 1000);
                    }

                    // Reset counter
                    openHandCounter = 0;
                    showElement(statusMessageElement, "Buka telapak tangan untuk memulai.");
                }
            } else {
                // Jika tangan hilang saat progress belum penuh
                if (openHandCounter > 0 && openHandCounter < thresholdFrames) {

                    //     // Tambahkan efek error merah ke scan-container
                    scanContainer.classList.add("error");
                    particleColor = 'rgba(255, 0, 0, 0.8)';
                        lineColor = 'rgba(255, 0, 0, 1)';

                    setTimeout(() => {
                        scanContainer.classList.remove("error");
                        particleColor = 'rgba(0, 255, 255, 0.8)';
                            lineColor = 'rgba(0, 255, 255, 1)';
                    }, 1000);
                }

                // Reset counter agar user harus mulai ulang
                openHandCounter = 0;
                showElement(instructionsElement);
            }
        }



        // --- FUNGSI INISIALISASI SETELAH INTERAKSI PENGGUNA ---
        function initializeApp() {
            startOverlay.style.display = 'none'; // Sembunyikan overlay

            // Trik untuk "membuka kunci" audio
            beepAudio.play().then(() => beepAudio.pause()).catch(e => console.log(
                "Audio context needs user interaction."));
            introAudio.play().then(() => introAudio.pause()).catch(e => { });

            // Inisialisasi MediaPipe Hands
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7,
            });
            hands.onResults(onResults);

            // Inisialisasi dan mulai kamera
            camera = new Camera(videoElement, {
                onFrame: async () => {
                    if (videoElement.readyState >= 2) {
                        await hands.send({
                            image: videoElement
                        });
                    }
                },
                width: 640,
                height: 480,
            });

            camera.start().catch(err => {
                console.error("Camera start failed:", err);
                showElement(instructionsElement, "Error: Tidak dapat mengakses kamera.");
            });
        }

        // --- EVENT LISTENER UNTUK TOMBOL MULAI ---
        startButton.addEventListener('click', initializeApp);

        // Atur progress bar ke 0 saat halaman dimuat
        setProgress(0);



        // --- SCRIPT PARTICLE DENGAN PENGHALANG LINGKARAN ---
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let particlesArray;
        let particleColor = 'rgba(0, 255, 255, 0.8)';
        let lineColor = 'rgba(0, 255, 255, 1)';

        const scanContainerElement = document.querySelector('.scan-container');

        class Particle {
            constructor(x, y, directionX, directionY, size, color) {
                this.x = x;
                this.y = y;
                this.directionX = directionX;
                this.directionY = directionY;
                this.size = size;
                this.color = color;
            }
            // draw() {
            //     ctx.beginPath();
            //     ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
            //     ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
            //     ctx.fill();
            // }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                ctx.fillStyle = particleColor;
                ctx.fill();
            }

            update() {
                if (this.x > canvas.width || this.x < 0) this.directionX *= -1;
                if (this.y > canvas.height || this.y < 0) this.directionY *= -1;

                const rect = scanContainerElement.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const radius = Math.max(rect.width, rect.height) / 2;

                let nextX = this.x + this.directionX;
                let nextY = this.y + this.directionY;
                const distNext = Math.sqrt((nextX - centerX) ** 2 + (nextY - centerY) ** 2);

                // Pantulkan jika akan masuk ke lingkaran
                if (distNext < radius + this.size) {
                    this.directionX *= -1;
                    this.directionY *= -1;
                    nextX = this.x + this.directionX;
                    nextY = this.y + this.directionY;
                }

                this.x = nextX;
                this.y = nextY;
                this.draw();
            }
        }

        function init() {
            particlesArray = [];
            let numberOfParticles = (canvas.height * canvas.width) / 25000;

            const rect = scanContainerElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const radius = Math.max(rect.width, rect.height) / 2;

            for (let i = 0; i < numberOfParticles; i++) {
                let size = (Math.random() * 2) + 1;
                let x, y, dist;
                do {
                    x = Math.random() * innerWidth;
                    y = Math.random() * innerHeight;
                    dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                } while (dist < radius + size);

                let dirX = (Math.random() * .3) - .15;
                let dirY = (Math.random() * .3) - .15;
                particlesArray.push(new Particle(x, y, dirX, dirY, size, 'rgba(0, 255, 255, 0.8)'));
            }
        }

        function connect() {
            for (let a = 0; a < particlesArray.length; a++) {
                for (let b = a; b < particlesArray.length; b++) {
                    let distance = ((particlesArray[a].x - particlesArray[b].x) ** 2) +
                        ((particlesArray[a].y - particlesArray[b].y) ** 2);
                    if (distance < 20000) {
                        let opacityValue = 1 - (distance / 20000);
                        // ctx.strokeStyle = `rgba(0, 255, 255, ${opacityValue})`;
                        ctx.strokeStyle = lineColor.replace("1)", `${opacityValue})`);

                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                        ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                        ctx.stroke();
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, innerWidth, innerHeight);

            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
            }
            connect();
        }

        window.addEventListener('resize', () => {
            canvas.width = innerWidth;
            canvas.height = innerHeight;
            init();
        });

        init();
        animate();
    </script>
</body>

</html>